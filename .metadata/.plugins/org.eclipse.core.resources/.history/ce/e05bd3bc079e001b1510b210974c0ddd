/*
 * as5147.c
 *
 *  Created on: Apr 15, 2021
 *      Author: mined
 */

#include "as5147.h"

static uint8_t chip_num;

int8_t as5147_Init(SPI_HandleTypeDef* hspix, GPIO_TypeDef* GPIO_port, uint16_t GPIO_num){

	chip_num = addChip(hspix, GPIO_port, GPIO_num);
	if(chip_num < 0){
		return -1;
	}

	registerRead(AS5047P_ERRFL);
	int16_t error = registerRead(AS5047P_ERRFL);

	if(error < 0) return -1;

	return 0;
}

int8_t as5147_setZeroPosition(){
	int16_t current_zero_position = 0;
	int16_t current_position = 0;
	uint16_t zero_position_L = 0;
	uint16_t zero_position_M = 0;
	int8_t error;

	current_zero_position = registerRead(AS5047P_ZPOSL);
	if(current_zero_position < 0) return -1;

	error = registerWrite(AS5047P_ZPOSL, current_zero_position & (AS5047P_ZPOSL_COMP_I_ERR_EN | AS5047P_ZPOSL_COMP_H_ERR_EN));
	error |= registerWrite(AS5047P_ZPOSL, 0x0000);
	if(error != 0) return -1;

	HAL_Delay(1);

	current_position = registerRead(AS5047P_ANGLECOM);
	if(current_position < 0) return -1;

	zero_position_L = (current_zero_position & (AS5047P_ZPOSL_COMP_I_ERR_EN | AS5047P_ZPOSL_COMP_H_ERR_EN) ) | (current_position & AS5047P_ZPOSL_ZPOSL);
	zero_position_M = (current_position >> 6 ) & AS5047P_ZPOSM_ZPOSM;

	error = registerWrite(AS5047P_ZPOSL, zero_position_L);
	error |= registerWrite(AS5047P_ZPOSM, zero_position_M);
	if(error != 0) return -1;

	HAL_Delay(1);

	return 0;
}

int16_t as5147_readPosition(){
	int16_t position = 0;

	position = registerRead(AS5047P_ANGLECOM);

	return position;
}

uint16_t registerRead(uint16_t resgister_address){
	int16_t register_data = 0;
	HAL_StatusTypeDef state = 0;

	Frame command = packCommandFrame(resgister_address, AS5047P_ACCESS_READ);
	state = wriet2ByteRegister(&command.raw, chip_num);
	if(state != HAL_OK) return -1;

	command = packCommandFrame(AS5047P_NOP, AS5047P_ACCESS_READ);
	register_data = readWrite2ByteRegister(&command.raw, chip_num);
	if(register_data < 0) return -1;

	return register_data;
}

int8_t registerWrite(uint16_t resgister_address, uint16_t data){
	HAL_StatusTypeDef state;
	int16_t response;

	Frame command = packCommandFrame(resgister_address, AS5047P_ACCESS_WRITE);
	state = wriet2ByteRegister(&command.raw, chip_num);
	if(state != HAL_OK) return -1;

	command = packCommandFrame(data, AS5047P_ACCESS_WRITE);
	response = readWrite2ByteRegister(&command.raw, chip_num);
	if(response < 0) return -1;

	return 0;
}

Frame packCommandFrame(uint16_t data, uint8_t rw){
	Frame frame = { 0, };
	frame.values.data = data & AS5047P_FRAME_DATA;
	frame.values.rw = rw;
	frame.values.pard = calcParity(frame.raw);

	return frame;
}

uint8_t calcParity(uint16_t data){
	data ^= data >> 8;              // example for 8-bir (this line scales it up to 16 bit)
	data ^= data >> 4;              // ( a b c d e f g h ) xor ( 0 0 0 0 a b c d ) = ( a b c d ae bf cg dh )
	data ^= data >> 2;              // ( a b c d ae bf cg dh ) xor ( 0 0 a b c d ae bf ) = ( a b ac bd ace bdf aceg bdfh )
	data ^= data >> 1;              // ( a b ac bd ace bdf aceg bdfh ) xor ( 0 a b ac bd ace bdf aceg ) = ( a ab abc abcd abcde abcdef abcdefg abcdefgh )

	data = data & 0x0001;

	return (uint8_t)data;
}
